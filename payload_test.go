package znp

import (
	"testing"

	. "gopkg.in/check.v1"
)

func Test(t *testing.T) { TestingT(t) }

type MySuite struct{}

var _ = Suite(&MySuite{})

func (s *MySuite) TestSerialize(c *C) {
	type Test struct {
		F0  uint8
		F1  uint16 `endianness:"be"`
		F2  uint16
		F3  uint32
		F4  [8]byte
		F5  [16]byte
		F6  [18]byte
		F7  [32]byte
		F8  [42]byte
		F9  [100]byte
		F11 string `hex:"uint64"` // string '0x00124b00019c2ee9'
		F12 [2]uint16
		F13 []*Network `len:"uint8"`
	}
	test := &Test{F0: 1, F1: 2, F2: 2, F3: 3, F11: "0x00124b00019c2ee9", F12: [2]uint16{4, 5},
		F13: []*Network{&Network{
			NeighborPanID:   500,
			LogicalChannel:  2,
			StackProfile:    3,
			ZigbeeVersion:   4,
			BeaconOrder:     5,
			SuperFrameOrder: 6,
			PermitJoin:      100,
		}},
	}
	payload := serialize(test)
	c.Assert(payload, DeepEquals, []byte{0x1, 0x0, 0x2, 0x2, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe9, 0x2e, 0x9c,
		0x1, 0x0, 0x4b, 0x12, 0x0, 0x4, 0x0, 0x5, 0x0, 0x1, 0xf4, 0x1, 0x2, 0x43, 0x65, 0x64})
}

// func (s *MySuite) TestDeserialize(c *C) {
// 	type Test struct {
// 		F0  uint8
// 		F1  uint16 `endianness:"be"`
// 		F2  uint16
// 		F3  uint32
// 		F4  [8]byte
// 		F5  [16]byte
// 		F6  [18]byte
// 		F7  [32]byte
// 		F8  [42]byte
// 		F9  [100]byte
// 		F11 string `hex:"uint64"` // string '0x00124b00019c2ee9'
// 		F12 [2]uint16
// 		F13 []*Network `len:"uint8"`
// 	}
// 	test := &Test{F0: 1, F1: 2, F2: 2, F3: 3, F11: "0x00124b00019c2ee9", F12: [2]uint16{4, 5},
// 		F13: []*Network{&Network{
// 			NeighborPanID:   500,
// 			LogicalChannel:  2,
// 			StackProfile:    3,
// 			ZigbeeVersion:   4,
// 			BeaconOrder:     5,
// 			SuperFrameOrder: 6,
// 			PermitJoin:      100,
// 		}},
// 	}
// 	res := &Test{}
// 	payload := []byte{0x1, 0x0, 0x2, 0x2, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
// 		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
// 		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
// 		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
// 		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
// 		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
// 		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
// 		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
// 		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
// 		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
// 		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
// 		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
// 		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe9, 0x2e, 0x9c,
// 		0x1, 0x0, 0x4b, 0x12, 0x0, 0x4, 0x0, 0x5, 0x0, 0x1, 0xf4, 0x1, 0x2, 0x43, 0x65, 0x64}
// 	deserialize(bytes.NewBuffer(payload), res)

// 	c.Assert(res, DeepEquals, test)
// }

// func (s *MySuite) TestSerializeDeserialize(c *C) {
// 	type Test struct {
// 		F0  uint8
// 		F1  uint16 `endianness:"be"`
// 		F2  uint16
// 		F3  uint32
// 		F4  [8]byte
// 		F5  [16]byte
// 		F6  [18]byte
// 		F7  [32]byte
// 		F8  [42]byte
// 		F9  [100]byte
// 		F10 string     `hex:"uint64"` // string '0x00124b00019c2ee9'
// 		F11 []uint16   `len:"uint8"`
// 		F12 []byte     `len:"uint8"`
// 		F13 []*Network `len:"uint8"`
// 		F14 *Capabilities
// 		F15 string `hex:"uint32"` // string '0x00124b00'
// 	}
// 	networks := []*Network{
// 		&Network{
// 			NeighborPanID:   400,
// 			LogicalChannel:  5,
// 			StackProfile:    4,
// 			ZigbeeVersion:   5,
// 			BeaconOrder:     6,
// 			SuperFrameOrder: 7,
// 			PermitJoin:      200,
// 		},
// 		&Network{
// 			NeighborPanID:   500,
// 			LogicalChannel:  2,
// 			StackProfile:    3,
// 			ZigbeeVersion:   4,
// 			BeaconOrder:     5,
// 			SuperFrameOrder: 6,
// 			PermitJoin:      100,
// 		},
// 	}
// 	test := &Test{F0: 1, F1: 2, F2: 2, F3: 3, F10: "0x00124b00019c2ee9",
// 		F11: []uint16{4, 5}, F12: []byte{1, 2, 3},
// 		F13: networks, F14: &Capabilities{1, 0, 0, 1, 1, 1, 1, 0, 1, 0}, F15: "0x00124b00"}
// 	payload := serialize(test)
// 	res := &Test{}
// 	deserialize(bytes.NewBuffer(payload), res)
// 	c.Assert(res, DeepEquals, test)
// }

// func (s *MySuite) TestDeserializeBitmask(c *C) {
// 	type Bitmask struct {
// 		F0 uint8
// 		F1 uint16 `bitmask:"start" bits:"0x0001"`
// 		F2 uint16 `bits:"0x0002"`
// 		F3 uint16 `bits:"0x0004"`
// 		F4 uint16 `bitmask:"end" bits:"0x0008"`
// 		F5 uint8
// 		F6 uint8 `bitmask:"start" bits:"0x01"`
// 		F7 uint8 `bitmask:"end" bits:"0x02"`
// 	}
// 	bitmask := &Bitmask{6, 1, 0, 0, 1, 7, 1, 1}
// 	res := &Bitmask{}
// 	payload := []byte{6, 9, 0, 7, 3}
// 	deserialize(bytes.NewBuffer(payload), res)

// 	c.Assert(res, DeepEquals, bitmask)
// }
