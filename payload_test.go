package znp

import (
	"bytes"
	"testing"

	. "gopkg.in/check.v1"
)

func Test(t *testing.T) { TestingT(t) }

type MySuite struct{}

var _ = Suite(&MySuite{})

func (s *MySuite) TestSerialize(c *C) {
	type Test struct {
		F0  uint8
		F1  uint16 `endianness:"be"`
		F2  uint16
		F3  uint32
		F4  [8]byte
		F5  [16]byte
		F6  [18]byte
		F7  [32]byte
		F8  [42]byte
		F9  [100]byte
		F11 string `hex:"uint64"` // string '0x00124b00019c2ee9'
		F12 [2]uint16
		F13 []*Network `len:"uint8"`
		F14 *Capabilities
		F15 []string `len:"uint8" hex:"uint16"`
		F16 AfInterPanCtlData
	}
	test := &Test{F0: 1, F1: 2, F2: 2, F3: 3, F11: "0x00124b00019c2ee9", F12: [2]uint16{4, 5},
		F13: []*Network{&Network{
			NeighborPanID:   500,
			LogicalChannel:  2,
			StackProfile:    3,
			ZigbeeVersion:   4,
			BeaconOrder:     5,
			SuperFrameOrder: 6,
			PermitJoin:      100,
		}},
		F14: &Capabilities{1, 0, 0, 1, 1, 1, 1, 0, 1, 0},
		F15: []string{"0xffaa", "0xaaff"},
		F16: &AfInterPanChkData{1, 2},
	}
	payload := serialize(test)
	c.Assert(payload, DeepEquals, []byte{0x1, 0x0, 0x2, 0x2, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe9, 0x2e, 0x9c,
		0x1, 0x0, 0x4b, 0x12, 0x0, 0x4, 0x0, 0x5, 0x0, 0x1, 0xf4, 0x1, 0x2, 0x43, 0x65, 0x64, 0x79, 0x1,
		0x02, 0xaa, 0xff, 0xff, 0xaa, 0x1, 0x0, 0x2})
}

func (s *MySuite) TestEnumSerialization(c *C) {
	request := &AfRegister{EndPoint: 1, AppProfID: 2, AppDeviceID: 3, AddDevVer: 4,
		LatencyReq: NoLatency, AppInClusterList: []uint16{5, 6}, AppOutClusterList: []uint16{7, 8}}
	payload := serialize(request)
	res := &AfRegister{}
	deserialize(bytes.NewBuffer(payload), res)
	c.Assert(res, DeepEquals, request)
}

func (s *MySuite) TestDeserialize(c *C) {
	type Status uint8
	const (
		NO Status = iota
		YES
	)

	type Statuses struct {
		Status1 Status `bitmask:"start" bits:"0x01"`
		Status2 Status `bitmask:"end" bits:"0x02"`
	}

	type Test struct {
		F0  uint8
		F1  uint16 `endianness:"be"`
		F2  uint16
		F3  uint32
		F4  [8]byte
		F5  [16]byte
		F6  [18]byte
		F7  [32]byte
		F8  [42]byte
		F9  [100]byte
		F11 string `hex:"uint64"` // string '0x00124b00019c2ee9'
		F12 [2]uint16
		F13 []*Network `len:"uint8"`
		F14 []string   `len:"uint8" hex:"uint16"`
		F15 string     `len:"uint8"`
		F16 *Statuses
	}
	test := &Test{F0: 1, F1: 2, F2: 2, F3: 3, F11: "0x00124b00019c2ee9", F12: [2]uint16{4, 5},
		F13: []*Network{&Network{
			NeighborPanID:   500,
			LogicalChannel:  2,
			StackProfile:    3,
			ZigbeeVersion:   4,
			BeaconOrder:     5,
			SuperFrameOrder: 6,
			PermitJoin:      100,
		}},
		F14: []string{"0xffaa", "0xaaff"},
		F15: "hello world",
		F16: &Statuses{YES, NO},
	}
	res := &Test{}
	payload := []byte{0x1, 0x0, 0x2, 0x2, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe9, 0x2e, 0x9c,
		0x1, 0x0, 0x4b, 0x12, 0x0, 0x4, 0x0, 0x5, 0x0, 0x1, 0xf4, 0x1, 0x2, 0x43, 0x65, 0x64, 0x02,
		0xaa, 0xff, 0xff, 0xaa, 0x0b, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x01}
	deserialize(bytes.NewBuffer(payload), res)

	c.Assert(res, DeepEquals, test)
}

func (s *MySuite) TestSerializeDeserialize(c *C) {
	type Test struct {
		F0  uint8
		F1  uint16 `endianness:"be"`
		F2  uint16
		F3  uint32
		F4  [8]byte
		F5  [16]byte
		F6  [18]byte
		F7  [32]byte
		F8  [42]byte
		F9  [100]byte
		F10 string     `hex:"uint64"` // string '0x00124b00019c2ee9'
		F11 []uint16   `len:"uint8"`
		F12 []byte     `len:"uint8"`
		F13 []*Network `len:"uint8"`
		F14 *Capabilities
		F15 string `hex:"uint32"` // string '0x00124b00'
		F16 string `len:"uint8"`
	}
	networks := []*Network{
		&Network{
			NeighborPanID:   400,
			LogicalChannel:  5,
			StackProfile:    4,
			ZigbeeVersion:   5,
			BeaconOrder:     6,
			SuperFrameOrder: 7,
			PermitJoin:      200,
		},
		&Network{
			NeighborPanID:   500,
			LogicalChannel:  2,
			StackProfile:    3,
			ZigbeeVersion:   4,
			BeaconOrder:     5,
			SuperFrameOrder: 6,
			PermitJoin:      100,
		},
	}
	test := &Test{F0: 1, F1: 2, F2: 2, F3: 3, F10: "0x00124b00019c2ee9",
		F11: []uint16{4, 5}, F12: []byte{1, 2, 3},
		F13: networks, F14: &Capabilities{1, 0, 0, 1, 1, 1, 1, 0, 1, 0}, F15: "0x00124b00",
		F16: "hello world"}
	payload := serialize(test)
	res := &Test{}
	deserialize(bytes.NewBuffer(payload), res)
	c.Assert(res, DeepEquals, test)
}

func (s *MySuite) TestDeserializeBitmask(c *C) {
	type Bitmask struct {
		F0 uint8
		F1 uint16 `bitmask:"start" bits:"0x0001"`
		F2 uint16 `bits:"0x0002"`
		F3 uint16 `bits:"0x0004"`
		F4 uint16 `bitmask:"end" bits:"0x0008"`
		F5 uint8
		F6 uint8 `bitmask:"start" bits:"0x01"`
		F7 uint8 `bitmask:"end" bits:"0x02"`
	}
	bitmask := &Bitmask{6, 1, 0, 0, 1, 7, 1, 1}
	res := &Bitmask{}
	payload := []byte{6, 9, 0, 7, 3}
	deserialize(bytes.NewBuffer(payload), res)

	c.Assert(res, DeepEquals, bitmask)
}
